{"version":3,"sources":["../../src/schemas/json-schema.ts","../../src/tools/mcp.ts"],"names":[],"mappings":"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","file":"mcp.js","sourcesContent":["/**\n * JSON Schema type definition (simplified for our needs)\n */\nexport interface JSONSchema {\n  type: string;\n  description?: string;\n  properties?: Record<string, JSONSchema>;\n  required?: string[];\n  additionalProperties?: boolean;\n  items?: JSONSchema;\n  enum?: string[];\n}\n\n/**\n * JSON Schema for bashlet_exec tool input\n */\nexport const execJsonSchema: JSONSchema = {\n  type: \"object\",\n  properties: {\n    command: {\n      type: \"string\",\n      description: \"The shell command to execute in the sandbox\",\n    },\n    workdir: {\n      type: \"string\",\n      description: \"Working directory inside the sandbox (default: /workspace)\",\n    },\n  },\n  required: [\"command\"],\n  additionalProperties: false,\n};\n\n/**\n * JSON Schema for bashlet_read_file tool input\n */\nexport const readFileJsonSchema: JSONSchema = {\n  type: \"object\",\n  properties: {\n    path: {\n      type: \"string\",\n      description: \"Absolute path to the file inside the sandbox\",\n    },\n  },\n  required: [\"path\"],\n  additionalProperties: false,\n};\n\n/**\n * JSON Schema for bashlet_write_file tool input\n */\nexport const writeFileJsonSchema: JSONSchema = {\n  type: \"object\",\n  properties: {\n    path: {\n      type: \"string\",\n      description: \"Absolute path to the file inside the sandbox\",\n    },\n    content: {\n      type: \"string\",\n      description: \"Content to write to the file\",\n    },\n  },\n  required: [\"path\", \"content\"],\n  additionalProperties: false,\n};\n\n/**\n * JSON Schema for bashlet_list_dir tool input\n */\nexport const listDirJsonSchema: JSONSchema = {\n  type: \"object\",\n  properties: {\n    path: {\n      type: \"string\",\n      description: \"Absolute path to the directory inside the sandbox\",\n    },\n  },\n  required: [\"path\"],\n  additionalProperties: false,\n};\n","import type { Bashlet } from \"../client.js\";\nimport {\n  execJsonSchema,\n  readFileJsonSchema,\n  writeFileJsonSchema,\n  listDirJsonSchema,\n  type JSONSchema,\n} from \"../schemas/json-schema.js\";\n\n/**\n * MCP tool definition structure\n */\nexport interface MCPToolDefinition {\n  name: string;\n  description: string;\n  inputSchema: JSONSchema;\n}\n\n/**\n * MCP tool content item\n */\nexport interface MCPToolContent {\n  type: \"text\";\n  text: string;\n}\n\n/**\n * MCP tool result\n */\nexport interface MCPToolResult {\n  content: MCPToolContent[];\n  isError?: boolean;\n}\n\n/**\n * MCP tool with handler\n */\nexport interface MCPToolHandler {\n  definition: MCPToolDefinition;\n  handler: (args: Record<string, unknown>) => Promise<MCPToolResult>;\n}\n\n/**\n * Generate MCP-compatible tool definitions with handlers.\n *\n * @param client - Bashlet client instance\n * @returns Array of MCP tool handlers\n *\n * @example\n * ```typescript\n * import { Server } from '@modelcontextprotocol/sdk/server/index.js';\n * import { Bashlet, generateMCPTools } from '@bashlet/sdk';\n *\n * const bashlet = new Bashlet();\n * const tools = generateMCPTools(bashlet);\n *\n * server.setRequestHandler('tools/list', async () => ({\n *   tools: tools.map(t => t.definition),\n * }));\n *\n * server.setRequestHandler('tools/call', async (request) => {\n *   const { name, arguments: args } = request.params;\n *   const tool = tools.find(t => t.definition.name === name);\n *   return tool.handler(args);\n * });\n * ```\n */\nexport function generateMCPTools(client: Bashlet): MCPToolHandler[] {\n  return [\n    {\n      definition: {\n        name: \"bashlet_exec\",\n        description:\n          \"Execute a shell command in a sandboxed bash environment. \" +\n          \"Returns stdout, stderr, and exit code. \" +\n          \"Use this for running shell commands, scripts, and system operations safely.\",\n        inputSchema: execJsonSchema,\n      },\n      handler: async (args) => {\n        const { command, workdir } = args as { command: string; workdir?: string };\n        try {\n          const result = await client.exec(command, { workdir });\n          return {\n            content: [\n              {\n                type: \"text\" as const,\n                text: JSON.stringify(\n                  {\n                    stdout: result.stdout,\n                    stderr: result.stderr,\n                    exitCode: result.exitCode,\n                  },\n                  null,\n                  2\n                ),\n              },\n            ],\n          };\n        } catch (error) {\n          return {\n            content: [{ type: \"text\" as const, text: String(error) }],\n            isError: true,\n          };\n        }\n      },\n    },\n    {\n      definition: {\n        name: \"bashlet_read_file\",\n        description:\n          \"Read the contents of a file from the sandboxed environment. \" +\n          \"Returns the file content as a string.\",\n        inputSchema: readFileJsonSchema,\n      },\n      handler: async (args) => {\n        const { path } = args as { path: string };\n        try {\n          const content = await client.readFile(path);\n          return { content: [{ type: \"text\" as const, text: content }] };\n        } catch (error) {\n          return {\n            content: [{ type: \"text\" as const, text: String(error) }],\n            isError: true,\n          };\n        }\n      },\n    },\n    {\n      definition: {\n        name: \"bashlet_write_file\",\n        description:\n          \"Write content to a file in the sandboxed environment. \" +\n          \"Creates the file if it doesn't exist, overwrites if it does.\",\n        inputSchema: writeFileJsonSchema,\n      },\n      handler: async (args) => {\n        const { path, content } = args as { path: string; content: string };\n        try {\n          await client.writeFile(path, content);\n          return {\n            content: [{ type: \"text\" as const, text: `Successfully wrote to ${path}` }],\n          };\n        } catch (error) {\n          return {\n            content: [{ type: \"text\" as const, text: String(error) }],\n            isError: true,\n          };\n        }\n      },\n    },\n    {\n      definition: {\n        name: \"bashlet_list_dir\",\n        description:\n          \"List the contents of a directory in the sandboxed environment. \" +\n          \"Returns a detailed listing with file permissions, sizes, and names.\",\n        inputSchema: listDirJsonSchema,\n      },\n      handler: async (args) => {\n        const { path } = args as { path: string };\n        try {\n          const listing = await client.listDir(path);\n          return { content: [{ type: \"text\" as const, text: listing }] };\n        } catch (error) {\n          return {\n            content: [{ type: \"text\" as const, text: String(error) }],\n            isError: true,\n          };\n        }\n      },\n    },\n  ];\n}\n\n/**\n * Create an MCP server helper with bashlet tools.\n *\n * @param client - Bashlet client instance\n * @returns Object with tools list and handler function\n *\n * @example\n * ```typescript\n * const bashlet = new Bashlet();\n * const { tools, handleToolCall } = createMCPServer(bashlet);\n *\n * // Use with MCP SDK\n * server.setRequestHandler('tools/list', async () => ({ tools }));\n * server.setRequestHandler('tools/call', async (req) =>\n *   handleToolCall(req.params.name, req.params.arguments)\n * );\n * ```\n */\nexport function createMCPServer(client: Bashlet) {\n  const toolHandlers = generateMCPTools(client);\n\n  return {\n    tools: toolHandlers.map((t) => t.definition),\n    handleToolCall: async (\n      name: string,\n      args: Record<string, unknown>\n    ): Promise<MCPToolResult> => {\n      const tool = toolHandlers.find((t) => t.definition.name === name);\n      if (!tool) {\n        return {\n          content: [{ type: \"text\", text: `Unknown tool: ${name}` }],\n          isError: true,\n        };\n      }\n      return tool.handler(args);\n    },\n  };\n}\n"]}