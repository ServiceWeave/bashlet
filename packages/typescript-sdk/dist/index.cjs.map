{"version":3,"sources":["../src/schemas/json-schema.ts","../src/tools/mcp.ts","../src/schemas/zod.ts","../src/tools/vercel.ts","../src/tools/openai.ts","../src/tools/generic.ts","../src/errors.ts","../src/client.ts","../src/schemas/index.ts","../src/tools/index.ts"],"names":["execJsonSchema","readFileJsonSchema","writeFileJsonSchema","listDirJsonSchema","execSchema","readFileSchema","writeFileSchema","listDirSchema","z","generateMCPTools","generateVercelTools","generateOpenAITools","generateGenericTools","execa","randomBytes","join","tmpdir","writeFileSync","existsSync","unlinkSync"],"mappings":"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","file":"index.cjs","sourcesContent":["/**\n * JSON Schema type definition (simplified for our needs)\n */\nexport interface JSONSchema {\n  type: string;\n  description?: string;\n  properties?: Record<string, JSONSchema>;\n  required?: string[];\n  additionalProperties?: boolean;\n  items?: JSONSchema;\n  enum?: string[];\n}\n\n/**\n * JSON Schema for bashlet_exec tool input\n */\nexport const execJsonSchema: JSONSchema = {\n  type: \"object\",\n  properties: {\n    command: {\n      type: \"string\",\n      description: \"The shell command to execute in the sandbox\",\n    },\n    workdir: {\n      type: \"string\",\n      description: \"Working directory inside the sandbox (default: /workspace)\",\n    },\n  },\n  required: [\"command\"],\n  additionalProperties: false,\n};\n\n/**\n * JSON Schema for bashlet_read_file tool input\n */\nexport const readFileJsonSchema: JSONSchema = {\n  type: \"object\",\n  properties: {\n    path: {\n      type: \"string\",\n      description: \"Absolute path to the file inside the sandbox\",\n    },\n  },\n  required: [\"path\"],\n  additionalProperties: false,\n};\n\n/**\n * JSON Schema for bashlet_write_file tool input\n */\nexport const writeFileJsonSchema: JSONSchema = {\n  type: \"object\",\n  properties: {\n    path: {\n      type: \"string\",\n      description: \"Absolute path to the file inside the sandbox\",\n    },\n    content: {\n      type: \"string\",\n      description: \"Content to write to the file\",\n    },\n  },\n  required: [\"path\", \"content\"],\n  additionalProperties: false,\n};\n\n/**\n * JSON Schema for bashlet_list_dir tool input\n */\nexport const listDirJsonSchema: JSONSchema = {\n  type: \"object\",\n  properties: {\n    path: {\n      type: \"string\",\n      description: \"Absolute path to the directory inside the sandbox\",\n    },\n  },\n  required: [\"path\"],\n  additionalProperties: false,\n};\n","import type { Bashlet } from \"../client.js\";\nimport {\n  execJsonSchema,\n  readFileJsonSchema,\n  writeFileJsonSchema,\n  listDirJsonSchema,\n  type JSONSchema,\n} from \"../schemas/json-schema.js\";\n\n/**\n * MCP tool definition structure\n */\nexport interface MCPToolDefinition {\n  name: string;\n  description: string;\n  inputSchema: JSONSchema;\n}\n\n/**\n * MCP tool content item\n */\nexport interface MCPToolContent {\n  type: \"text\";\n  text: string;\n}\n\n/**\n * MCP tool result\n */\nexport interface MCPToolResult {\n  content: MCPToolContent[];\n  isError?: boolean;\n}\n\n/**\n * MCP tool with handler\n */\nexport interface MCPToolHandler {\n  definition: MCPToolDefinition;\n  handler: (args: Record<string, unknown>) => Promise<MCPToolResult>;\n}\n\n/**\n * Generate MCP-compatible tool definitions with handlers.\n *\n * @param client - Bashlet client instance\n * @returns Array of MCP tool handlers\n *\n * @example\n * ```typescript\n * import { Server } from '@modelcontextprotocol/sdk/server/index.js';\n * import { Bashlet, generateMCPTools } from '@bashlet/sdk';\n *\n * const bashlet = new Bashlet();\n * const tools = generateMCPTools(bashlet);\n *\n * server.setRequestHandler('tools/list', async () => ({\n *   tools: tools.map(t => t.definition),\n * }));\n *\n * server.setRequestHandler('tools/call', async (request) => {\n *   const { name, arguments: args } = request.params;\n *   const tool = tools.find(t => t.definition.name === name);\n *   return tool.handler(args);\n * });\n * ```\n */\nexport function generateMCPTools(client: Bashlet): MCPToolHandler[] {\n  return [\n    {\n      definition: {\n        name: \"bashlet_exec\",\n        description:\n          \"Execute a shell command in a sandboxed bash environment. \" +\n          \"Returns stdout, stderr, and exit code. \" +\n          \"Use this for running shell commands, scripts, and system operations safely.\",\n        inputSchema: execJsonSchema,\n      },\n      handler: async (args) => {\n        const { command, workdir } = args as { command: string; workdir?: string };\n        try {\n          const result = await client.exec(command, { workdir });\n          return {\n            content: [\n              {\n                type: \"text\" as const,\n                text: JSON.stringify(\n                  {\n                    stdout: result.stdout,\n                    stderr: result.stderr,\n                    exitCode: result.exitCode,\n                  },\n                  null,\n                  2\n                ),\n              },\n            ],\n          };\n        } catch (error) {\n          return {\n            content: [{ type: \"text\" as const, text: String(error) }],\n            isError: true,\n          };\n        }\n      },\n    },\n    {\n      definition: {\n        name: \"bashlet_read_file\",\n        description:\n          \"Read the contents of a file from the sandboxed environment. \" +\n          \"Returns the file content as a string.\",\n        inputSchema: readFileJsonSchema,\n      },\n      handler: async (args) => {\n        const { path } = args as { path: string };\n        try {\n          const content = await client.readFile(path);\n          return { content: [{ type: \"text\" as const, text: content }] };\n        } catch (error) {\n          return {\n            content: [{ type: \"text\" as const, text: String(error) }],\n            isError: true,\n          };\n        }\n      },\n    },\n    {\n      definition: {\n        name: \"bashlet_write_file\",\n        description:\n          \"Write content to a file in the sandboxed environment. \" +\n          \"Creates the file if it doesn't exist, overwrites if it does.\",\n        inputSchema: writeFileJsonSchema,\n      },\n      handler: async (args) => {\n        const { path, content } = args as { path: string; content: string };\n        try {\n          await client.writeFile(path, content);\n          return {\n            content: [{ type: \"text\" as const, text: `Successfully wrote to ${path}` }],\n          };\n        } catch (error) {\n          return {\n            content: [{ type: \"text\" as const, text: String(error) }],\n            isError: true,\n          };\n        }\n      },\n    },\n    {\n      definition: {\n        name: \"bashlet_list_dir\",\n        description:\n          \"List the contents of a directory in the sandboxed environment. \" +\n          \"Returns a detailed listing with file permissions, sizes, and names.\",\n        inputSchema: listDirJsonSchema,\n      },\n      handler: async (args) => {\n        const { path } = args as { path: string };\n        try {\n          const listing = await client.listDir(path);\n          return { content: [{ type: \"text\" as const, text: listing }] };\n        } catch (error) {\n          return {\n            content: [{ type: \"text\" as const, text: String(error) }],\n            isError: true,\n          };\n        }\n      },\n    },\n  ];\n}\n\n/**\n * Create an MCP server helper with bashlet tools.\n *\n * @param client - Bashlet client instance\n * @returns Object with tools list and handler function\n *\n * @example\n * ```typescript\n * const bashlet = new Bashlet();\n * const { tools, handleToolCall } = createMCPServer(bashlet);\n *\n * // Use with MCP SDK\n * server.setRequestHandler('tools/list', async () => ({ tools }));\n * server.setRequestHandler('tools/call', async (req) =>\n *   handleToolCall(req.params.name, req.params.arguments)\n * );\n * ```\n */\nexport function createMCPServer(client: Bashlet) {\n  const toolHandlers = generateMCPTools(client);\n\n  return {\n    tools: toolHandlers.map((t) => t.definition),\n    handleToolCall: async (\n      name: string,\n      args: Record<string, unknown>\n    ): Promise<MCPToolResult> => {\n      const tool = toolHandlers.find((t) => t.definition.name === name);\n      if (!tool) {\n        return {\n          content: [{ type: \"text\", text: `Unknown tool: ${name}` }],\n          isError: true,\n        };\n      }\n      return tool.handler(args);\n    },\n  };\n}\n","import { z } from \"zod\";\n\n/**\n * Schema for bashlet_exec tool input\n */\nexport const execSchema = z.object({\n  command: z.string().describe(\"The shell command to execute in the sandbox\"),\n  workdir: z\n    .string()\n    .optional()\n    .describe(\"Working directory inside the sandbox (default: /workspace)\"),\n});\n\n/**\n * Schema for bashlet_read_file tool input\n */\nexport const readFileSchema = z.object({\n  path: z.string().describe(\"Absolute path to the file inside the sandbox\"),\n});\n\n/**\n * Schema for bashlet_write_file tool input\n */\nexport const writeFileSchema = z.object({\n  path: z.string().describe(\"Absolute path to the file inside the sandbox\"),\n  content: z.string().describe(\"Content to write to the file\"),\n});\n\n/**\n * Schema for bashlet_list_dir tool input\n */\nexport const listDirSchema = z.object({\n  path: z.string().describe(\"Absolute path to the directory inside the sandbox\"),\n});\n\n// Type exports for TypeScript inference\nexport type ExecInput = z.infer<typeof execSchema>;\nexport type ReadFileInput = z.infer<typeof readFileSchema>;\nexport type WriteFileInput = z.infer<typeof writeFileSchema>;\nexport type ListDirInput = z.infer<typeof listDirSchema>;\n","import type { Bashlet } from \"../client.js\";\nimport {\n  execSchema,\n  readFileSchema,\n  writeFileSchema,\n  listDirSchema,\n  type ExecInput,\n  type ReadFileInput,\n  type WriteFileInput,\n  type ListDirInput,\n} from \"../schemas/zod.js\";\n\n/**\n * Vercel AI SDK tool structure\n * Compatible with the `tool()` helper from the `ai` package\n */\nexport interface VercelTool<TInput, TOutput> {\n  description: string;\n  parameters: typeof execSchema | typeof readFileSchema | typeof writeFileSchema | typeof listDirSchema;\n  execute: (args: TInput) => Promise<TOutput>;\n}\n\n/**\n * Exec tool output type\n */\nexport interface ExecOutput {\n  stdout: string;\n  stderr: string;\n  exitCode: number;\n}\n\n/**\n * Read file output type\n */\nexport interface ReadFileOutput {\n  content: string;\n}\n\n/**\n * Write file output type\n */\nexport interface WriteFileOutput {\n  success: boolean;\n  path: string;\n}\n\n/**\n * List directory output type\n */\nexport interface ListDirOutput {\n  listing: string;\n}\n\n/**\n * Tools record type for Vercel AI SDK\n */\nexport interface BashletVercelTools {\n  bashlet_exec: VercelTool<ExecInput, ExecOutput>;\n  bashlet_read_file: VercelTool<ReadFileInput, ReadFileOutput>;\n  bashlet_write_file: VercelTool<WriteFileInput, WriteFileOutput>;\n  bashlet_list_dir: VercelTool<ListDirInput, ListDirOutput>;\n}\n\n/**\n * Generate Vercel AI SDK-compatible tools.\n *\n * These tools are designed to work with the `ai` package's `generateText`\n * and `streamText` functions.\n *\n * @param client - Bashlet client instance\n * @returns Object with tool definitions\n *\n * @example\n * ```typescript\n * import { generateText } from 'ai';\n * import { openai } from '@ai-sdk/openai';\n * import { Bashlet, generateVercelTools } from '@bashlet/sdk';\n *\n * const bashlet = new Bashlet({\n *   mounts: [{ hostPath: './project', guestPath: '/workspace' }],\n * });\n *\n * const result = await generateText({\n *   model: openai('gpt-4-turbo'),\n *   tools: generateVercelTools(bashlet),\n *   prompt: 'List files in /workspace and show the contents of package.json',\n * });\n * ```\n */\nexport function generateVercelTools(client: Bashlet): BashletVercelTools {\n  return {\n    bashlet_exec: {\n      description:\n        \"Execute a shell command in a sandboxed bash environment. \" +\n        \"Returns stdout, stderr, and exit code. \" +\n        \"Use this for running shell commands, scripts, and system operations safely.\",\n      parameters: execSchema,\n      execute: async ({ command, workdir }: ExecInput): Promise<ExecOutput> => {\n        const result = await client.exec(command, { workdir });\n        return {\n          stdout: result.stdout,\n          stderr: result.stderr,\n          exitCode: result.exitCode,\n        };\n      },\n    },\n\n    bashlet_read_file: {\n      description:\n        \"Read the contents of a file from the sandboxed environment. \" +\n        \"Returns the file content as a string.\",\n      parameters: readFileSchema,\n      execute: async ({ path }: ReadFileInput): Promise<ReadFileOutput> => {\n        const content = await client.readFile(path);\n        return { content };\n      },\n    },\n\n    bashlet_write_file: {\n      description:\n        \"Write content to a file in the sandboxed environment. \" +\n        \"Creates the file if it doesn't exist, overwrites if it does.\",\n      parameters: writeFileSchema,\n      execute: async ({ path, content }: WriteFileInput): Promise<WriteFileOutput> => {\n        await client.writeFile(path, content);\n        return { success: true, path };\n      },\n    },\n\n    bashlet_list_dir: {\n      description:\n        \"List the contents of a directory in the sandboxed environment. \" +\n        \"Returns a detailed listing with file permissions, sizes, and names.\",\n      parameters: listDirSchema,\n      execute: async ({ path }: ListDirInput): Promise<ListDirOutput> => {\n        const listing = await client.listDir(path);\n        return { listing };\n      },\n    },\n  };\n}\n","import type { Bashlet } from \"../client.js\";\nimport {\n  execJsonSchema,\n  readFileJsonSchema,\n  writeFileJsonSchema,\n  listDirJsonSchema,\n  type JSONSchema,\n} from \"../schemas/json-schema.js\";\n\n/**\n * OpenAI function calling tool structure\n */\nexport interface OpenAITool {\n  type: \"function\";\n  function: {\n    name: string;\n    description: string;\n    parameters: JSONSchema;\n  };\n}\n\n/**\n * OpenAI tool with handler for executing tool calls\n */\nexport interface OpenAIToolWithHandler extends OpenAITool {\n  handler: (args: Record<string, unknown>) => Promise<string>;\n}\n\n/**\n * Generate OpenAI function calling-compatible tools with handlers.\n *\n * @param client - Bashlet client instance\n * @returns Array of OpenAI tools with handlers\n *\n * @example\n * ```typescript\n * import OpenAI from 'openai';\n * import { Bashlet, generateOpenAITools } from '@bashlet/sdk';\n *\n * const openai = new OpenAI();\n * const bashlet = new Bashlet();\n * const tools = generateOpenAITools(bashlet);\n *\n * const response = await openai.chat.completions.create({\n *   model: 'gpt-4-turbo',\n *   tools: tools.map(t => ({ type: t.type, function: t.function })),\n *   messages: [{ role: 'user', content: 'List files in the current directory' }],\n * });\n *\n * // Handle tool calls\n * for (const toolCall of response.choices[0].message.tool_calls ?? []) {\n *   const tool = tools.find(t => t.function.name === toolCall.function.name);\n *   const result = await tool.handler(JSON.parse(toolCall.function.arguments));\n *   console.log(result);\n * }\n * ```\n */\nexport function generateOpenAITools(client: Bashlet): OpenAIToolWithHandler[] {\n  return [\n    {\n      type: \"function\",\n      function: {\n        name: \"bashlet_exec\",\n        description:\n          \"Execute a shell command in a sandboxed bash environment. \" +\n          \"Returns stdout, stderr, and exit code. \" +\n          \"Use this for running shell commands, scripts, and system operations safely.\",\n        parameters: execJsonSchema,\n      },\n      handler: async (args) => {\n        const { command, workdir } = args as { command: string; workdir?: string };\n        const result = await client.exec(command, { workdir });\n        return JSON.stringify({\n          stdout: result.stdout,\n          stderr: result.stderr,\n          exitCode: result.exitCode,\n        });\n      },\n    },\n    {\n      type: \"function\",\n      function: {\n        name: \"bashlet_read_file\",\n        description:\n          \"Read the contents of a file from the sandboxed environment. \" +\n          \"Returns the file content as a string.\",\n        parameters: readFileJsonSchema,\n      },\n      handler: async (args) => {\n        const { path } = args as { path: string };\n        return await client.readFile(path);\n      },\n    },\n    {\n      type: \"function\",\n      function: {\n        name: \"bashlet_write_file\",\n        description:\n          \"Write content to a file in the sandboxed environment. \" +\n          \"Creates the file if it doesn't exist, overwrites if it does.\",\n        parameters: writeFileJsonSchema,\n      },\n      handler: async (args) => {\n        const { path, content } = args as { path: string; content: string };\n        await client.writeFile(path, content);\n        return JSON.stringify({ success: true, path });\n      },\n    },\n    {\n      type: \"function\",\n      function: {\n        name: \"bashlet_list_dir\",\n        description:\n          \"List the contents of a directory in the sandboxed environment. \" +\n          \"Returns a detailed listing with file permissions, sizes, and names.\",\n        parameters: listDirJsonSchema,\n      },\n      handler: async (args) => {\n        const { path } = args as { path: string };\n        return await client.listDir(path);\n      },\n    },\n  ];\n}\n\n/**\n * Get just the tool definitions (for passing to OpenAI API).\n *\n * @param client - Bashlet client instance\n * @returns Array of OpenAI tool definitions (without handlers)\n *\n * @example\n * ```typescript\n * const tools = getOpenAIToolDefinitions(bashlet);\n * const response = await openai.chat.completions.create({\n *   model: 'gpt-4-turbo',\n *   tools,\n *   messages: [...],\n * });\n * ```\n */\nexport function getOpenAIToolDefinitions(client: Bashlet): OpenAITool[] {\n  return generateOpenAITools(client).map(({ type, function: fn }) => ({\n    type,\n    function: fn,\n  }));\n}\n\n/**\n * Create a tool handler map for processing tool calls.\n *\n * @param client - Bashlet client instance\n * @returns Function that handles tool calls by name\n *\n * @example\n * ```typescript\n * const handleToolCall = createOpenAIToolHandler(bashlet);\n *\n * // After getting tool calls from OpenAI response\n * for (const toolCall of response.choices[0].message.tool_calls) {\n *   const result = await handleToolCall(\n *     toolCall.function.name,\n *     JSON.parse(toolCall.function.arguments)\n *   );\n *   // Send result back to OpenAI\n * }\n * ```\n */\nexport function createOpenAIToolHandler(client: Bashlet) {\n  const tools = generateOpenAITools(client);\n  const handlerMap = new Map(tools.map((t) => [t.function.name, t.handler]));\n\n  return async (name: string, args: Record<string, unknown>): Promise<string> => {\n    const handler = handlerMap.get(name);\n    if (!handler) {\n      throw new Error(`Unknown tool: ${name}`);\n    }\n    return handler(args);\n  };\n}\n","import type { Bashlet } from \"../client.js\";\nimport {\n  execJsonSchema,\n  readFileJsonSchema,\n  writeFileJsonSchema,\n  listDirJsonSchema,\n  type JSONSchema,\n} from \"../schemas/json-schema.js\";\n\n/**\n * Generic tool definition that can be adapted to any AI framework.\n */\nexport interface GenericTool<TInput = Record<string, unknown>, TOutput = unknown> {\n  /** Tool name */\n  name: string;\n  /** Human-readable description */\n  description: string;\n  /** JSON Schema for input parameters */\n  parameters: JSONSchema;\n  /** Execute the tool with given arguments */\n  execute: (args: TInput) => Promise<TOutput>;\n}\n\n/**\n * Input types for generic tools\n */\nexport interface ExecArgs {\n  command: string;\n  workdir?: string;\n}\n\nexport interface ReadFileArgs {\n  path: string;\n}\n\nexport interface WriteFileArgs {\n  path: string;\n  content: string;\n}\n\nexport interface ListDirArgs {\n  path: string;\n}\n\n/**\n * Output types for generic tools\n */\nexport interface ExecResult {\n  stdout: string;\n  stderr: string;\n  exitCode: number;\n}\n\nexport interface WriteFileResult {\n  success: boolean;\n  path: string;\n}\n\n/**\n * Generate framework-agnostic tool definitions.\n *\n * These tools can be adapted to work with any AI agent framework\n * by using the JSON Schema parameters and execute function.\n *\n * @param client - Bashlet client instance\n * @returns Array of generic tool definitions\n *\n * @example\n * ```typescript\n * import { Bashlet, generateGenericTools } from '@bashlet/sdk';\n *\n * const bashlet = new Bashlet();\n * const tools = generateGenericTools(bashlet);\n *\n * // Use with any custom AI agent implementation\n * for (const tool of tools) {\n *   console.log(`Tool: ${tool.name}`);\n *   console.log(`Description: ${tool.description}`);\n *   console.log(`Parameters: ${JSON.stringify(tool.parameters)}`);\n *\n *   // Execute the tool\n *   const result = await tool.execute({ command: 'ls' });\n * }\n * ```\n */\nexport function generateGenericTools(client: Bashlet): GenericTool[] {\n  return [\n    {\n      name: \"bashlet_exec\",\n      description:\n        \"Execute a shell command in a sandboxed bash environment. \" +\n        \"Returns stdout, stderr, and exit code. \" +\n        \"Use this for running shell commands, scripts, and system operations safely.\",\n      parameters: execJsonSchema,\n      execute: async (args): Promise<ExecResult> => {\n        const { command, workdir } = args as unknown as ExecArgs;\n        const result = await client.exec(command, { workdir });\n        return {\n          stdout: result.stdout,\n          stderr: result.stderr,\n          exitCode: result.exitCode,\n        };\n      },\n    },\n    {\n      name: \"bashlet_read_file\",\n      description:\n        \"Read the contents of a file from the sandboxed environment. \" +\n        \"Returns the file content as a string.\",\n      parameters: readFileJsonSchema,\n      execute: async (args): Promise<string> => {\n        const { path } = args as unknown as ReadFileArgs;\n        return await client.readFile(path);\n      },\n    },\n    {\n      name: \"bashlet_write_file\",\n      description:\n        \"Write content to a file in the sandboxed environment. \" +\n        \"Creates the file if it doesn't exist, overwrites if it does.\",\n      parameters: writeFileJsonSchema,\n      execute: async (args): Promise<WriteFileResult> => {\n        const { path, content } = args as unknown as WriteFileArgs;\n        await client.writeFile(path, content);\n        return { success: true, path };\n      },\n    },\n    {\n      name: \"bashlet_list_dir\",\n      description:\n        \"List the contents of a directory in the sandboxed environment. \" +\n        \"Returns a detailed listing with file permissions, sizes, and names.\",\n      parameters: listDirJsonSchema,\n      execute: async (args): Promise<string> => {\n        const { path } = args as unknown as ListDirArgs;\n        return await client.listDir(path);\n      },\n    },\n  ];\n}\n\n/**\n * Create a tool registry for looking up and executing tools by name.\n *\n * @param client - Bashlet client instance\n * @returns Object with tools map and execute helper\n *\n * @example\n * ```typescript\n * const registry = createToolRegistry(bashlet);\n *\n * // Get tool by name\n * const execTool = registry.get('bashlet_exec');\n *\n * // Execute tool by name\n * const result = await registry.execute('bashlet_exec', { command: 'ls' });\n * ```\n */\nexport function createToolRegistry(client: Bashlet) {\n  const tools = generateGenericTools(client);\n  const toolMap = new Map(tools.map((t) => [t.name, t]));\n\n  return {\n    /** Get all tools as an array */\n    all: () => tools,\n\n    /** Get a tool by name */\n    get: (name: string) => toolMap.get(name),\n\n    /** Check if a tool exists */\n    has: (name: string) => toolMap.has(name),\n\n    /** Execute a tool by name */\n    execute: async (name: string, args: Record<string, unknown>) => {\n      const tool = toolMap.get(name);\n      if (!tool) {\n        throw new Error(`Unknown tool: ${name}`);\n      }\n      return tool.execute(args);\n    },\n\n    /** Get tool names */\n    names: () => Array.from(toolMap.keys()),\n  };\n}\n","/**\n * Base error class for all bashlet SDK errors\n */\nexport class BashletError extends Error {\n  constructor(\n    message: string,\n    public readonly cause?: unknown\n  ) {\n    super(message);\n    this.name = \"BashletError\";\n    // Maintains proper stack trace for where error was thrown (V8 engines)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, BashletError);\n    }\n  }\n}\n\n/**\n * Error thrown when command execution fails\n */\nexport class CommandExecutionError extends BashletError {\n  constructor(\n    message: string,\n    public readonly exitCode: number,\n    public readonly stderr: string\n  ) {\n    super(message);\n    this.name = \"CommandExecutionError\";\n  }\n}\n\n/**\n * Error thrown when session operations fail\n */\nexport class SessionError extends BashletError {\n  constructor(\n    message: string,\n    public readonly sessionId?: string\n  ) {\n    super(message);\n    this.name = \"SessionError\";\n  }\n}\n\n/**\n * Error thrown when configuration is invalid\n */\nexport class ConfigurationError extends BashletError {\n  constructor(message: string) {\n    super(message);\n    this.name = \"ConfigurationError\";\n  }\n}\n\n/**\n * Error thrown when the bashlet binary is not found or inaccessible\n */\nexport class BinaryNotFoundError extends BashletError {\n  constructor(binaryPath: string) {\n    super(\n      `Bashlet binary not found at '${binaryPath}'. ` +\n        `Make sure bashlet is installed and available in your PATH, ` +\n        `or specify the correct path using the 'binaryPath' option.`\n    );\n    this.name = \"BinaryNotFoundError\";\n  }\n}\n\n/**\n * Error thrown when command times out\n */\nexport class TimeoutError extends BashletError {\n  constructor(\n    command: string,\n    timeoutSeconds: number\n  ) {\n    super(\n      `Command timed out after ${timeoutSeconds} seconds: ${command.substring(0, 100)}${command.length > 100 ? \"...\" : \"\"}`\n    );\n    this.name = \"TimeoutError\";\n  }\n}\n","import { execa } from \"execa\";\nimport type {\n  BashletOptions,\n  CreateSessionOptions,\n  ExecOptions,\n  CommandResult,\n  Session,\n  BashletJsonOutput,\n  SessionListItem,\n  SshOptions,\n} from \"./types.js\";\nimport { tmpdir } from \"os\";\nimport { join } from \"path\";\nimport { writeFileSync, unlinkSync, existsSync } from \"fs\";\nimport { randomBytes } from \"crypto\";\nimport {\n  BashletError,\n  CommandExecutionError,\n  BinaryNotFoundError,\n  TimeoutError,\n} from \"./errors.js\";\n\n/**\n * Bashlet client for sandboxed bash execution.\n *\n * Provides methods for:\n * - One-shot command execution\n * - Session management (create, run, terminate)\n * - File operations (read, write, list)\n * - Tool generation for AI agent frameworks\n *\n * @example\n * ```typescript\n * const bashlet = new Bashlet({\n *   mounts: [{ hostPath: './src', guestPath: '/workspace' }],\n * });\n *\n * const result = await bashlet.exec('ls -la /workspace');\n * console.log(result.stdout);\n * ```\n */\nexport class Bashlet {\n  private readonly binaryPath: string;\n  private readonly defaultOptions: BashletOptions;\n\n  constructor(options: BashletOptions = {}) {\n    this.binaryPath = options.binaryPath ?? \"bashlet\";\n    this.defaultOptions = options;\n  }\n\n  // ============================================================================\n  // One-Shot Execution\n  // ============================================================================\n\n  /**\n   * Execute a one-shot command in an isolated sandbox.\n   * Creates a sandbox, runs the command, and tears down.\n   *\n   * @param command - Shell command to execute\n   * @param options - Execution options (mounts, env vars, etc.)\n   * @returns Command result with stdout, stderr, and exit code\n   *\n   * @example\n   * ```typescript\n   * const result = await bashlet.exec('echo \"Hello World\"');\n   * console.log(result.stdout); // \"Hello World\\n\"\n   * ```\n   */\n  async exec(command: string, options: ExecOptions = {}): Promise<CommandResult> {\n    const mergedOptions = this.mergeOptions(options);\n    const args = this.buildExecArgs(command, mergedOptions);\n    return this.runCommand([\"exec\", ...args], mergedOptions.timeout);\n  }\n\n  // ============================================================================\n  // Session Management\n  // ============================================================================\n\n  /**\n   * Create a new persistent sandbox session.\n   *\n   * @param options - Session creation options\n   * @returns Session ID or name\n   *\n   * @example\n   * ```typescript\n   * const sessionId = await bashlet.createSession({\n   *   name: 'my-session',\n   *   ttl: '1h',\n   *   mounts: [{ hostPath: './project', guestPath: '/workspace' }],\n   * });\n   * ```\n   */\n  async createSession(options: CreateSessionOptions = {}): Promise<string> {\n    const args = this.buildCreateArgs(options);\n    const result = await this.runCommand([\"create\", ...args]);\n    return this.parseSessionCreateResult(result);\n  }\n\n  /**\n   * Run a command in an existing session.\n   *\n   * @param sessionId - Session ID or name\n   * @param command - Command to execute\n   * @param options - Additional options\n   * @returns Command result\n   *\n   * @example\n   * ```typescript\n   * const result = await bashlet.runInSession('my-session', 'npm install');\n   * ```\n   */\n  async runInSession(\n    sessionId: string,\n    command: string,\n    options: { createIfMissing?: boolean; preset?: string } = {}\n  ): Promise<CommandResult> {\n    const args: string[] = [];\n\n    if (options.createIfMissing) {\n      args.push(\"-C\");\n    }\n\n    if (options.preset) {\n      args.push(\"--preset\", options.preset);\n    }\n\n    args.push(sessionId, command);\n\n    return this.runCommand([\"run\", ...args]);\n  }\n\n  /**\n   * Terminate a session.\n   *\n   * @param sessionId - Session ID or name to terminate\n   *\n   * @example\n   * ```typescript\n   * await bashlet.terminate('my-session');\n   * ```\n   */\n  async terminate(sessionId: string): Promise<void> {\n    await this.runCommand([\"terminate\", sessionId]);\n  }\n\n  /**\n   * List all active sessions.\n   *\n   * @returns Array of session information\n   *\n   * @example\n   * ```typescript\n   * const sessions = await bashlet.listSessions();\n   * for (const session of sessions) {\n   *   console.log(`${session.id}: ${session.name ?? 'unnamed'}`);\n   * }\n   * ```\n   */\n  async listSessions(): Promise<Session[]> {\n    const result = await this.runCommand([\"list\"]);\n    return this.parseSessionList(result);\n  }\n\n  // ============================================================================\n  // File Operations\n  // ============================================================================\n\n  /**\n   * Read a file from the sandbox.\n   *\n   * @param path - Path to the file inside the sandbox\n   * @param options - Execution options\n   * @returns File contents as string\n   *\n   * @example\n   * ```typescript\n   * const content = await bashlet.readFile('/workspace/package.json');\n   * const pkg = JSON.parse(content);\n   * ```\n   */\n  async readFile(path: string, options: ExecOptions = {}): Promise<string> {\n    const escapedPath = this.escapeShellArg(path);\n    const result = await this.exec(`cat ${escapedPath}`, options);\n\n    if (result.exitCode !== 0) {\n      throw new CommandExecutionError(\n        `Failed to read file: ${path}`,\n        result.exitCode,\n        result.stderr\n      );\n    }\n\n    return result.stdout;\n  }\n\n  /**\n   * Write content to a file in the sandbox.\n   *\n   * @param path - Path to the file inside the sandbox\n   * @param content - Content to write\n   * @param options - Execution options\n   *\n   * @example\n   * ```typescript\n   * await bashlet.writeFile('/workspace/output.txt', 'Hello World');\n   * ```\n   */\n  async writeFile(\n    path: string,\n    content: string,\n    options: ExecOptions = {}\n  ): Promise<void> {\n    const escapedPath = this.escapeShellArg(path);\n    // Use base64 encoding to handle special characters safely\n    const encoded = Buffer.from(content).toString(\"base64\");\n    const command = `echo '${encoded}' | base64 -d > ${escapedPath}`;\n\n    const result = await this.exec(command, options);\n\n    if (result.exitCode !== 0) {\n      throw new CommandExecutionError(\n        `Failed to write file: ${path}`,\n        result.exitCode,\n        result.stderr\n      );\n    }\n  }\n\n  /**\n   * List directory contents.\n   *\n   * @param path - Path to the directory inside the sandbox\n   * @param options - Execution options\n   * @returns Directory listing as string\n   *\n   * @example\n   * ```typescript\n   * const listing = await bashlet.listDir('/workspace');\n   * console.log(listing);\n   * ```\n   */\n  async listDir(path: string, options: ExecOptions = {}): Promise<string> {\n    const escapedPath = this.escapeShellArg(path);\n    const result = await this.exec(`ls -la ${escapedPath}`, options);\n\n    if (result.exitCode !== 0) {\n      throw new CommandExecutionError(\n        `Failed to list directory: ${path}`,\n        result.exitCode,\n        result.stderr\n      );\n    }\n\n    return result.stdout;\n  }\n\n  // ============================================================================\n  // Tool Generators\n  // ============================================================================\n\n  /**\n   * Generate MCP-compatible tool definitions.\n   * For use with Model Context Protocol servers.\n   *\n   * @example\n   * ```typescript\n   * import { Server } from '@modelcontextprotocol/sdk/server/index.js';\n   *\n   * const bashlet = new Bashlet();\n   * const tools = bashlet.toMCPTools();\n   *\n   * server.setRequestHandler('tools/list', async () => ({\n   *   tools: tools.map(t => t.definition),\n   * }));\n   * ```\n   */\n  toMCPTools() {\n    // Dynamic import to avoid bundling MCP SDK when not needed\n    const { generateMCPTools } = require(\"./tools/mcp.js\");\n    return generateMCPTools(this);\n  }\n\n  /**\n   * Generate Vercel AI SDK-compatible tools.\n   * For use with the `ai` package's generateText/streamText.\n   *\n   * @example\n   * ```typescript\n   * import { generateText } from 'ai';\n   * import { openai } from '@ai-sdk/openai';\n   *\n   * const bashlet = new Bashlet();\n   * const result = await generateText({\n   *   model: openai('gpt-4-turbo'),\n   *   tools: bashlet.toVercelTools(),\n   *   prompt: 'List files in /workspace',\n   * });\n   * ```\n   */\n  toVercelTools() {\n    const { generateVercelTools } = require(\"./tools/vercel.js\");\n    return generateVercelTools(this);\n  }\n\n  /**\n   * Generate OpenAI function calling-compatible tools.\n   * For use with OpenAI's chat completions API.\n   *\n   * @example\n   * ```typescript\n   * import OpenAI from 'openai';\n   *\n   * const bashlet = new Bashlet();\n   * const tools = bashlet.toOpenAITools();\n   *\n   * const response = await openai.chat.completions.create({\n   *   model: 'gpt-4-turbo',\n   *   tools: tools.map(t => ({ type: t.type, function: t.function })),\n   *   messages: [...],\n   * });\n   * ```\n   */\n  toOpenAITools() {\n    const { generateOpenAITools } = require(\"./tools/openai.js\");\n    return generateOpenAITools(this);\n  }\n\n  /**\n   * Generate framework-agnostic tool definitions.\n   * For use with custom AI agent implementations.\n   *\n   * @example\n   * ```typescript\n   * const bashlet = new Bashlet();\n   * const tools = bashlet.toGenericTools();\n   *\n   * for (const tool of tools) {\n   *   console.log(tool.name, tool.description);\n   *   // Use tool.parameters for JSON Schema\n   *   // Use tool.execute(args) to run the tool\n   * }\n   * ```\n   */\n  toGenericTools() {\n    const { generateGenericTools } = require(\"./tools/generic.js\");\n    return generateGenericTools(this);\n  }\n\n  // ============================================================================\n  // Private Helpers\n  // ============================================================================\n\n  private mergeOptions(options: ExecOptions): ExecOptions {\n    return {\n      preset: options.preset ?? this.defaultOptions.preset,\n      mounts: [...(this.defaultOptions.mounts ?? []), ...(options.mounts ?? [])],\n      envVars: [...(this.defaultOptions.envVars ?? []), ...(options.envVars ?? [])],\n      workdir: options.workdir ?? this.defaultOptions.workdir,\n      timeout: options.timeout ?? this.defaultOptions.timeout ?? 300,\n      backend: options.backend ?? this.defaultOptions.backend,\n      ssh: options.ssh ?? this.defaultOptions.ssh,\n    };\n  }\n\n  private async runCommand(\n    args: string[],\n    timeoutSeconds?: number\n  ): Promise<CommandResult> {\n    const fullArgs = [\"--format\", \"json\", ...args];\n\n    if (this.defaultOptions.configPath) {\n      fullArgs.unshift(\"--config\", this.defaultOptions.configPath);\n    }\n\n    try {\n      const subprocess = execa(this.binaryPath, fullArgs, {\n        timeout: (timeoutSeconds ?? 300) * 1000,\n        reject: false,\n      });\n\n      const { stdout, stderr, exitCode, timedOut } = await subprocess;\n\n      if (timedOut) {\n        throw new TimeoutError(args.join(\" \"), timeoutSeconds ?? 300);\n      }\n\n      // Parse JSON output\n      try {\n        const parsed = JSON.parse(stdout) as BashletJsonOutput;\n\n        // Check for error in JSON response\n        if (parsed.error) {\n          throw new BashletError(parsed.error);\n        }\n\n        return {\n          stdout: parsed.stdout ?? \"\",\n          stderr: parsed.stderr ?? stderr,\n          exitCode: parsed.exit_code ?? exitCode ?? 0,\n        };\n      } catch (e) {\n        // If not valid JSON and not our error, return raw output\n        if (e instanceof BashletError) {\n          throw e;\n        }\n        return { stdout, stderr, exitCode: exitCode ?? 0 };\n      }\n    } catch (error) {\n      if (error instanceof BashletError) {\n        throw error;\n      }\n\n      const execError = error as Error & { code?: string };\n\n      // Check for binary not found\n      if (execError.code === \"ENOENT\") {\n        throw new BinaryNotFoundError(this.binaryPath);\n      }\n\n      throw new BashletError(\n        `Failed to execute bashlet: ${execError.message}`,\n        error\n      );\n    }\n  }\n\n  /** Track temp config files for cleanup */\n  private tempConfigFiles: string[] = [];\n\n  private buildExecArgs(command: string, options: ExecOptions): string[] {\n    const args: string[] = [];\n\n    if (options.preset) {\n      args.push(\"--preset\", options.preset);\n    }\n\n    if (options.backend) {\n      args.push(\"--backend\", options.backend);\n    }\n\n    // Handle SSH configuration by creating a temporary config file\n    if (options.ssh) {\n      const configPath = this.createSshConfigFile(options.ssh);\n      args.push(\"--config\", configPath);\n    }\n\n    for (const mount of options.mounts ?? []) {\n      const mountStr = mount.readonly\n        ? `${mount.hostPath}:${mount.guestPath}:ro`\n        : `${mount.hostPath}:${mount.guestPath}`;\n      args.push(\"--mount\", mountStr);\n    }\n\n    for (const env of options.envVars ?? []) {\n      args.push(\"--env\", `${env.key}=${env.value}`);\n    }\n\n    if (options.workdir) {\n      args.push(\"--workdir\", options.workdir);\n    }\n\n    args.push(command);\n    return args;\n  }\n\n  /**\n   * Create a temporary config file with SSH settings.\n   * The file is automatically cleaned up when the client is garbage collected.\n   */\n  private createSshConfigFile(ssh: SshOptions): string {\n    const config = {\n      ssh: {\n        host: ssh.host,\n        port: ssh.port ?? 22,\n        user: ssh.user,\n        key_file: ssh.keyFile,\n        use_control_master: ssh.useControlMaster ?? true,\n        connect_timeout: ssh.connectTimeout ?? 30,\n      },\n    };\n\n    const configId = randomBytes(8).toString(\"hex\");\n    const configPath = join(tmpdir(), `bashlet-ssh-${configId}.json`);\n    writeFileSync(configPath, JSON.stringify(config, null, 2));\n    this.tempConfigFiles.push(configPath);\n\n    return configPath;\n  }\n\n  /**\n   * Clean up temporary config files.\n   * Called automatically but can also be called manually.\n   */\n  cleanup(): void {\n    for (const configPath of this.tempConfigFiles) {\n      if (existsSync(configPath)) {\n        try {\n          unlinkSync(configPath);\n        } catch {\n          // Ignore cleanup errors\n        }\n      }\n    }\n    this.tempConfigFiles = [];\n  }\n\n  private buildCreateArgs(options: CreateSessionOptions): string[] {\n    const args: string[] = [];\n\n    if (options.name) {\n      args.push(\"--name\", options.name);\n    }\n\n    if (options.preset) {\n      args.push(\"--preset\", options.preset);\n    }\n\n    for (const mount of options.mounts ?? []) {\n      const mountStr = mount.readonly\n        ? `${mount.hostPath}:${mount.guestPath}:ro`\n        : `${mount.hostPath}:${mount.guestPath}`;\n      args.push(\"--mount\", mountStr);\n    }\n\n    for (const env of options.envVars ?? []) {\n      args.push(\"--env\", `${env.key}=${env.value}`);\n    }\n\n    if (options.workdir) {\n      args.push(\"--workdir\", options.workdir);\n    }\n\n    if (options.ttl) {\n      args.push(\"--ttl\", options.ttl);\n    }\n\n    return args;\n  }\n\n  private parseSessionCreateResult(result: CommandResult): string {\n    // JSON output contains { id, name }\n    try {\n      const parsed = JSON.parse(result.stdout) as { id: string; name?: string };\n      return parsed.name ?? parsed.id;\n    } catch {\n      // Fallback to raw output\n      return result.stdout.trim();\n    }\n  }\n\n  private parseSessionList(result: CommandResult): Session[] {\n    try {\n      const items = JSON.parse(result.stdout) as SessionListItem[];\n      return items.map((item) => ({\n        id: item.id,\n        name: item.name,\n        createdAt: item.created_at,\n        lastActivity: item.last_activity,\n        ttlSeconds: item.ttl_seconds,\n        expired: item.expired,\n        mounts: item.mounts.map((m) => ({\n          hostPath: m.host_path,\n          guestPath: m.guest_path,\n          readonly: m.readonly,\n        })),\n        workdir: item.workdir,\n      }));\n    } catch {\n      return [];\n    }\n  }\n\n  private escapeShellArg(arg: string): string {\n    // Escape single quotes by ending the string, adding escaped quote, starting new string\n    return `'${arg.replace(/'/g, \"'\\\\''\")}'`;\n  }\n}\n","// Zod schemas (for Vercel AI SDK)\nexport {\n  execSchema,\n  readFileSchema,\n  writeFileSchema,\n  listDirSchema,\n  type ExecInput,\n  type ReadFileInput,\n  type WriteFileInput,\n  type ListDirInput,\n} from \"./zod.js\";\n\n// JSON schemas (for MCP, OpenAI)\nexport {\n  execJsonSchema,\n  readFileJsonSchema,\n  writeFileJsonSchema,\n  listDirJsonSchema,\n  type JSONSchema,\n} from \"./json-schema.js\";\n","// MCP tools\nexport {\n  generateMCPTools,\n  createMCPServer,\n  type MCPToolDefinition,\n  type MCPToolContent,\n  type MCPToolResult,\n  type MCPToolHandler,\n} from \"./mcp.js\";\n\n// Vercel AI SDK tools\nexport {\n  generateVercelTools,\n  type VercelTool,\n  type BashletVercelTools,\n  type ExecOutput,\n  type ReadFileOutput,\n  type WriteFileOutput,\n  type ListDirOutput,\n} from \"./vercel.js\";\n\n// OpenAI function calling tools\nexport {\n  generateOpenAITools,\n  getOpenAIToolDefinitions,\n  createOpenAIToolHandler,\n  type OpenAITool,\n  type OpenAIToolWithHandler,\n} from \"./openai.js\";\n\n// Generic/framework-agnostic tools\nexport {\n  generateGenericTools,\n  createToolRegistry,\n  type GenericTool,\n  type ExecArgs,\n  type ReadFileArgs,\n  type WriteFileArgs,\n  type ListDirArgs,\n  type ExecResult,\n  type WriteFileResult,\n} from \"./generic.js\";\n"]}